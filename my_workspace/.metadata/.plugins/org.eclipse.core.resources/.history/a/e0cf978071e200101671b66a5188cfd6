/*
 * stm32f407xx_gpio_driver.c
 *
 *  Created on: 22 Dec 2025
 *      Author: Sayad Hassan
 */

#include "stm32f407xx_gpio_driver.h"


/*********************************************************************
 * @fn      		  - GPIO_PeriClockControl
 *
 * @brief             - This function enables or disables peripheral clock for the given GPIO port
 *
 * @param[in]         - base address of the gpio peripheral
 * @param[in]         - ENABLE or DISABLE macros
 * @param[in]         -
 *
 * @return            -  none
 *
 * @Note              -  none

 */

void GPIO_PeriClockControl(GPIO_RegDef_t *pGPIOxReg, uint8_t EnorDi)
{
	if (EnorDi == ENABLE)
	{
	    if (pGPIOxReg == GPIOA)
	    {
	        GPIOA_PERI_CLK_EN();
	    }
	    else if (pGPIOxReg == GPIOB)
	    {
	        GPIOB_PERI_CLK_EN();
	    }
	    else if (pGPIOxReg == GPIOC)
	    {
	        GPIOC_PERI_CLK_EN();
	    }
	    else if (pGPIOxReg == GPIOD)
	    {
	        GPIOD_PERI_CLK_EN();
	    }
	    else if (pGPIOxReg == GPIOE)
	    {
	        GPIOE_PERI_CLK_EN();
	    }
	    else if (pGPIOxReg == GPIOF)
	    {
	        GPIOF_PERI_CLK_EN();
	    }
	    else if (pGPIOxReg == GPIOG)
	    {
	        GPIOG_PERI_CLK_EN();
	    }
	    else if (pGPIOxReg == GPIOH)
	    {
	        GPIOH_PERI_CLK_EN();
	    }
	    else if (pGPIOxReg == GPIOI)
	    {
	        GPIOI_PERI_CLK_EN();
	    }
	} else
	{
		if (pGPIOxReg == GPIOA)
		{
			GPIOA_PERI_CLK_DI();
		}
		else if (pGPIOxReg == GPIOB)
		{
			GPIOB_PERI_CLK_DI();
		}
		else if (pGPIOxReg == GPIOC)
		{
			GPIOC_PERI_CLK_DI();
		}
		else if (pGPIOxReg == GPIOD)
		{
			GPIOD_PERI_CLK_DI();
		}
		else if (pGPIOxReg == GPIOE)
		{
			GPIOE_PERI_CLK_DI();
		}
		else if (pGPIOxReg == GPIOF)
		{
			GPIOF_PERI_CLK_DI();
		}
		else if (pGPIOxReg == GPIOG)
		{
			GPIOG_PERI_CLK_DI();
		}
		else if (pGPIOxReg == GPIOH)
		{
			GPIOH_PERI_CLK_DI();
		}
		else if (pGPIOxReg == GPIOI)
		{
			GPIOI_PERI_CLK_DI();
		}
	}

}



/*********************************************************************
 * @fn      		  - GPIO_Init
 *
 * @brief             -
 *
 * @param[in]         -
 * @param[in]         -
 * @param[in]         -
 *
 * @return            -
 *
 * @Note              -

 */

void GPIO_Init(GPIO_Handle_t *pGPIOHandle)
{
	uint32_t temp = 0;

	// 1. Configure GPIOx pin mode

	// When Pin mode is Input, General purpose output mode, Alternate function mode, Analog mode

	if (pGPIOHandle->GPIOPinConfig.GPIO_PinMode <= GPIO_MODE_ANALOG)
	{
		// non-interrupt mode

		temp = ( pGPIOHandle->GPIOPinConfig.GPIO_PinMode << (2 * pGPIOHandle->GPIOPinConfig.GPIO_PinNumber) );
		pGPIOHandle->pGPIOxReg->MODER |= temp;

	} else
	{
		// interrupt mode
	}


	temp = 0;

	// 2. Configure GPIOx output type
	temp = ( pGPIOHandle->GPIOPinConfig.GPIO_PinOPType << (pGPIOHandle->GPIOPinConfig.GPIO_PinNumber) );
	pGPIOHandle->pGPIOxReg->OTYPER |= temp;

	temp = 0;

	// 3. Configure GPIOx output speed
	temp = ( pGPIOHandle->GPIOPinConfig.GPIO_PinSpeed << (2 * pGPIOHandle->GPIOPinConfig.GPIO_PinNumber) );
	pGPIOHandle->pGPIOxReg->OSPEEDR |= temp;

	temp = 0;

	// 4. Configure GPIOx pull-up/pull-down
	temp = ( pGPIOHandle->GPIOPinConfig.GPIO_PinPuPdControl << (2 * pGPIOHandle->GPIOPinConfig.GPIO_PinNumber) );
	pGPIOHandle->pGPIOxReg->PUPDR |= temp;

	temp = 0;

	// 5. Configure GPIOx alternate function

	temp = ( pGPIOHandle->GPIOPinConfig.GPIO_PinAltFunMode << (2 * pGPIOHandle->GPIOPinConfig.GPIO_PinNumber) );
	pGPIOHandle->pGPIOxReg->PUPDR |= temp;
}



/*********************************************************************
 * @fn      		  - GPIO_DeInit
 *
 * @brief             -
 *
 * @param[in]         -
 * @param[in]         -
 * @param[in]         -
 *
 * @return            -
 *
 * @Note              -

 */

void GPIO_DeInit(GPIO_RegDef_t *pGPIOxReg);













