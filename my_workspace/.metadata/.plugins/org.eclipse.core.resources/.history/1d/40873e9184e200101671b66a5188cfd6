/*
 * stm32f407xx_gpio_driver.c
 *
 *  Created on: 22 Dec 2025
 *  Author:     Sayad Hassan
 */

#include "stm32f407xx_gpio_driver.h"


/*********************************************************************
 * @fn      		  - GPIO_PeriClockControl
 *
 * @brief             - Enables or disables the peripheral clock
 *                      for the given GPIO port.
 *
 * @param[pGPIOxReg]  - Base address of GPIO peripheral register block.
 * @param[EnorDi]     - ENABLE to enable clock,
 *                      DISABLE to disable clock.
 *
 * @return            - None
 *
 * @note              - This function must be called before accessing
 *                       GPIO registers or initializing a GPIO pin.
 *********************************************************************/

void GPIO_PeriClockControl(GPIO_RegDef_t *pGPIOxReg, uint8_t EnorDi)
{
	if (EnorDi == ENABLE)
	{
	    if (pGPIOxReg == GPIOA)      GPIOA_PERI_CLK_EN();
	    else if (pGPIOxReg == GPIOB) GPIOB_PERI_CLK_EN();
	    else if (pGPIOxReg == GPIOC) GPIOC_PERI_CLK_EN();
	    else if (pGPIOxReg == GPIOD) GPIOD_PERI_CLK_EN();
	    else if (pGPIOxReg == GPIOE) GPIOE_PERI_CLK_EN();
	    else if (pGPIOxReg == GPIOF) GPIOF_PERI_CLK_EN();
	    else if (pGPIOxReg == GPIOG) GPIOG_PERI_CLK_EN();
	    else if (pGPIOxReg == GPIOH) GPIOH_PERI_CLK_EN();
	    else if (pGPIOxReg == GPIOI) GPIOI_PERI_CLK_EN();
	}
	else
	{
	    if (pGPIOxReg == GPIOA)      GPIOA_PERI_CLK_DI();
	    else if (pGPIOxReg == GPIOB) GPIOB_PERI_CLK_DI();
	    else if (pGPIOxReg == GPIOC) GPIOC_PERI_CLK_DI();
	    else if (pGPIOxReg == GPIOD) GPIOD_PERI_CLK_DI();
	    else if (pGPIOxReg == GPIOE) GPIOE_PERI_CLK_DI();
	    else if (pGPIOxReg == GPIOF) GPIOF_PERI_CLK_DI();
	    else if (pGPIOxReg == GPIOG) GPIOG_PERI_CLK_DI();
	    else if (pGPIOxReg == GPIOH) GPIOH_PERI_CLK_DI();
	    else if (pGPIOxReg == GPIOI) GPIOI_PERI_CLK_DI();
	}
}


/*********************************************************************
 * @fn      		   - GPIO_Init
 *
 * @brief              - Initializes a GPIO pin according to the
 *                      onfiguration provided in GPIO_Handle_t.
 *
 * @param[pGPIOHandle] - Pointer to GPIO handle structure which contains:
 *                     - GPIO port base address
 *                     - GPIO pin configuration parameters
 *
 * @return             - None
 *
 * @note               - Call GPIO_PeriClockControl() before this function.
 *                       Supports non-interrupt and alternate-function modes.
 *********************************************************************/

void GPIO_Init(GPIO_Handle_t *pGPIOHandle)
{
	uint32_t temp = 0;

	/* 1. Configure GPIO pin mode (non-interrupt modes only) */
	if (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode <= GPIO_MODE_ANALOG)
	{
		temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode
		       << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));

		pGPIOHandle->pGPIOx->MODER &= ~(0x3 << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
		pGPIOHandle->pGPIOx->MODER |= temp;
	}
	else
	{
		/* TODO: Configure interrupt mode */
	}



	temp = 0;

	/* 2. Configure Output Type */
	temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinOPType
		   << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);

	pGPIOHandle->pGPIOx->OTYPER &= ~(1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
	pGPIOHandle->pGPIOx->OTYPER |= temp;

	temp = 0;

	/* 3. Configure Output Speed */
	temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinSpeed
		   << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));

	pGPIOHandle->pGPIOx->OSPEEDR &= ~(0x3 << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOHandle->pGPIOx->OSPEEDR |= temp;

	temp = 0;

	/* 4. Configure Pull-up / Pull-down */
	temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinPuPdControl
		   << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));

	pGPIOHandle->pGPIOx->PUPDR &= ~(0x3 << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOHandle->pGPIOx->PUPDR |= temp;



	/* 5. Configure Alternate Function */
	if (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_ALTFN)
	{
		uint8_t temp1 = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber / 8;
		uint8_t temp2 = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber % 8;

		pGPIOHandle->pGPIOx->AFR[temp1] &= ~(0xF << (4 * temp2));
		pGPIOHandle->pGPIOx->AFR[temp1] |=
				(pGPIOHandle->GPIO_PinConfig.GPIO_PinAltFunMode << (4 * temp2));
	}
}


/*********************************************************************
 * @fn      		  - GPIO_DeInit
 *
 * @brief             - Resets the GPIO peripheral registers to
 *                    	their default reset values.
 *
 * @param[pGPIOxReg]  - Base address of GPIO peripheral.
 *
 * @return            - None
 *
 * @note              - Uses RCC reset macros to reset registers.
 *********************************************************************/

void GPIO_DeInit(GPIO_RegDef_t *pGPIOxReg)
{
	if     (pGPIOxReg == GPIOA) GPIOA_REG_RESET();
	else if(pGPIOxReg == GPIOB) GPIOB_REG_RESET();
	else if(pGPIOxReg == GPIOC) GPIOC_REG_RESET();
	else if(pGPIOxReg == GPIOD) GPIOD_REG_RESET();
	else if(pGPIOxReg == GPIOE) GPIOE_REG_RESET();
	else if(pGPIOxReg == GPIOF) GPIOF_REG_RESET();
	else if(pGPIOxReg == GPIOG) GPIOG_REG_RESET();
	else if(pGPIOxReg == GPIOH) GPIOH_REG_RESET();
	else if(pGPIOxReg == GPIOI) GPIOI_REG_RESET();
}


uint8_t GPIO_ReadFromInputPin(GPIO_RegDef_t *pGPIOxReg, uint8_t PinNumber)
{
	uint8_t value;
	value = (uint8_t) pGPIOxReg->IDR >> PinNumber & 0x1;
	return value;
}






uint16_t GPIO_ReadFromInputPort(GPIO_RegDef_t *pGPIOxReg)
{
	uint16_t value;
	value = (uint16_t) pGPIOxReg->IDR;
	return value;
}





void GPIO_WriteToOutputPin(GPIO_RegDef_t *pGPIOxReg, uint8_t PinNumber, uint8_t Value)
{
	if (Value == GPIO_PIN_SET)
	{
		pGPIOxReg->ODR |= (1 << PinNumber);
	} else
	{
		//write 0, GPIO_PIN_RESET
		pGPIOxReg->ODR &= ~(1 << PinNumber);
	}
}





void GPIO_WriteToOutputPort(GPIO_RegDef_t *pGPIOxReg, uint16_t Value)
{
	pGPIOxReg->ODR = Value;
}



void GPIO_ToggleOutputPin(GPIO_RegDef_t *pGPIOxReg, uint8_t PinNumber)
{
	pGPIOxReg->ODR = (1 << PinNumber);
}







